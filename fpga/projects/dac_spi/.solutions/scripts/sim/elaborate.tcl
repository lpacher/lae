##
## Example custom Tcl-based simulation flow to run XSim simulation flows interactively [ELABORATION step]
##
## This script is a port in Tcl (with extensions) of the default elaborate.bat (elaborate.sh)
## script automatically generated by Vivado when running HDL simulations is project-mode.
##
## Luca Pacher - pacher@to.infn.it
## Fall 2020
##


####################################################################################################
##
## **NOTE
##
## Vivado extensively supports scripts-based flows either in so called "project" or "non-project"
## modes. Indeed, there is no "non-project mode" Tcl simulation flow. A "non-project" simulation flow
## is actually a true "batch flow" and requires to call standalone xvlog/xvhdl, xelab and xsim executables
## from the command-line, from a shell script or inside a GNU Makefile.
##
## However in "non-project mode" the simulation can't be re-invoked from the XSim GUI using
## Run > Relaunch Simulation (or using the relaunch_sim command) after RTL or testbench changes,
## thus requiring to exit from XSim and re-build the simulation from scratch. This happens because
## the XSim standalone flow doesn't keep track of xvlog/xvhdl and xelab flows.
##
## In order to be able to "relaunch" a simulation from the GUI you necessarily have to create a project
## in Vivado or to use a "project mode" Tcl script to automate the simulation.
## The overhead of creating an in-memory project is low compared to the benefits of fully automated
## one-step compilation/elaboration/simulation and re-launch features.
##
## This **CUSTOM** Tcl-based simulation flow basically reproduces all compilation/elaboration/simulation
## steps that actually Vivado performs "under the hood" for you without notice in project-mode.
## Most important, this custom flow is **PORTABLE** across Linux/Windows systems and allows
## to "relaunch" a simulation after RTL or testbench changes from the XSim Tcl console without
## the need of creating a project.
##
## Ref. also to  https://www.edn.com/improve-fpga-project-management-test-by-eschewing-the-ide
##
####################################################################################################


proc elaborate {} {

   ## profiling
   set tclStart [clock seconds]


   #############################################################
   ##   top-level module/entity to be elaborated (required)   ##
   #############################################################

   if { [info exists ::env(SIM_TOP_MODULE)] } {

      set xelabTop ${::env(SIM_TOP_MODULE)}

      puts "\n**INFO: Top-level testbench module: ${xelabTop}\n\n"

   } else {

      puts "\n**ERROR \[TCL\]: Unknown top-level module for design elaboration! Force an exit.\n\n"

      ## script failure
      exit 1
   }


   #########################################
   ##   move to simulation working area   ##
   #########################################

   ## **IMPORTANT: assume to run the flow inside WORK_DIR/sim (the WORK_DIR environment variable is exported by Makefile)

   if { [info exists ::env(WORK_DIR)] } {

      cd ${::env(WORK_DIR)}/sim

   } else {


      puts "**WARN \[TCL\]: WORK_DIR environment variable not defined, assuming ./work/sim to run simulation flows."

      if { ![file exists work] } { file mkdir work/sim }
      cd work/sim
   }


   ####################################
   ##   design elaboration (xelab)   ##
   ####################################

   ## log directory
   set logDir  [pwd]/../../log ; if { ![file exists ${logDir}] } { file mkdir ${logDir} }

   ## log file
   set logFile ${logDir}/elaborate.log

   ## delete the previous log file if exists
   if { [file exists ${logFile}] } {

      file delete ${logFile}
   }

   ##
   ## **IMPORTANT
   ##
   ## If a VHDL source to be simulated already contains Xilinx FPGA primitives (e.g. IBUF, OBUF etc.)
   ## then pre-compiled simulation libraries e.g. UNISIM, SIMIPRIME, SECUREIP etc. must be referenced
   ## in the code using
   ##
   ##    library UNISIM ;
   ##    use UNISIM.vcomponents.all ;
   ##
   ## at the beginning of each VHDL source file referencing FPGA primitives. Verilog sources using 
   ## FPGA device primitives are resolved instead with -L as external pre-compiled libraries, but
   ## also require $XILINX_VIVADO/data/verilog/src/glbl.v to be compiled and elaborated along with
   ## all other sources. Ref. also to https://www.xilinx.com/support/answers/63985.html
   ##
   ## As already done for the compilation flow, by using the 'catch' Tcl command the elaboration process
   ## will continue until the end despite ELABORATION ERRORS are present inside compiled sources.
   ## All elaboration errors are then shown on the console using 'grep' on the log file.
   ##


   puts "\n-- Elaborating the design ...\n"

   #catch {exec xelab -relax -mt 2 \
   #   -L work -L xil_defaultlib -L xpm -L unisims_ver -L unimacro_ver -L secureip \
   #   -debug all work.${xelabTop} -snapshot ${xelabTop} -nolog >@stdout 2>@stdout | tee ${logFile} }

   catch {exec xelab -relax -mt 2 \
      -L work -L xil_defaultlib -L xpm -L unisims_ver -L unimacro_ver -L secureip \
      -debug all work.${xelabTop} work.glbl -snapshot ${xelabTop} -nolog >@stdout 2>@stdout | tee ${logFile} }

   ## report CPU time
   set tclStop [clock seconds]
   set seconds [expr ${tclStop} - ${tclStart} ]

   puts "\nTotal elapsed-time for ELABORATION: [format "%.2f" [expr $seconds/60.]] minutes\n"


   ######################################
   ##   check for elaboration errors   ##
   ######################################

   puts "\n-- Checking for elaboration errors ...\n"

   if { [catch {exec grep --color ERROR ${logFile} >@stdout 2>@stdout }] } {

      puts "\t================================="
      puts "\t   NO ELABORATION ERRORS FOUND   "
      puts "\t================================="
      puts "\n"

      return 0

   } else {

      puts "\n"
      puts "\t==================================="
      puts "\t   ELABORATION ERRORS DETECTED !   "
      puts "\t==================================="
      puts "\n"

      puts "Please, fix all elaboration errors and recompile sources.\n"

      return 1
   }
}


## optionally, run the Tcl procedure when the script is executed by tclsh from Makefile
if { ${argc} == 1 } {

   if { [lindex ${argv} 0] eq "elaborate" } {

      puts "\n**INFO \[TCL\]: Running [file normalize  [info script]]\n"

      if { [elaborate] } {

         ## elaboration contains errors, exit with non-zero error code
         puts "Elaboration **FAILED**"

         ## script failure
         exit 1

      } else {

         ## elaboration OK
         exit 0
      }

   } else {

      ## invalid script argument, exit with non-zero error code
      puts "**ERROR \[TCL\]: Unknow option [lindex ${argv} 0]"

      ## script failure
      exit 1

   }
}

