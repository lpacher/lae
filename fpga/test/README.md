
# Sample Xilinx Vivado simulation and implementation flows

# Contents

* [**Introduction**](#introduction)
* [**Prerequisites**](#prerequisites)
* [**Navigate to the test directory**](#navigate-to-the-test-directory)
* [**Setup the working area**](#setup-the-working-area)
* [**Compile IP cores**](#compile-ip-cores)
* [**Run a behavioral simulation using XSim**](#run-a-behavioral-simulation-using-xsim)
* [**Implement the design on a target FPGA**](#implement-the-design-on-a-target-fpga)
* [**Install and debug the firmware (optional)**](#install-and-debug-the-firmware)


<br />
<!--------------------------------------------------------------------->


# Introduction
[**[Contents]**](#contents)

A small **mixed-language HDL design example** is provided to help students in testing their overall **command-line environment setup**
and all **software installations** required for the course. 

The proposed digital system is a **26-bit synchronous counter** with count-enable and active-high synchronous reset
described in Verilog. The code also instantiates a compiled **Phase-Locked Loop (PLL)** clock-management **Xilinx IP core**
to divide by a factor 10 the input clock and additional **FPGA device primitives** in form of **pre-placed buffer cells**
in order to demonstrate how to use and simulate device primitives in your projects.
For test purposes, one of these buffers has been "wrapped" into a **VHDL component**. <br />

The behaviour of the counter can be simulated using a **Verilog testbench module** that generates clock, reset
and enable control signals to verify the expected functionality of the design before mapping the code to FPGA.
Also the testbench has mixed-language features, with the main clock stimulus generated by another VHDL component
to show how we can simulate mixed-language designs using the **Xilinx XSim simulator** without the need
of a commercial license (on the contrary, other professional digital simulators such as Mentor ModelSim/QuestaSim
or Cadence IES/Xcelium require a full license).

The code is synthesizable and can be implemented on real FPGA hardware targeting
the [**Digilent Arty A7 development board**](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists/)
as used through the course. Additional debug features are also part of the implemented design.

![](./doc/pictures/rtl_schematic.png)



<br />
<!--------------------------------------------------------------------->



# Prerequisites
[**[Contents]**](#contents)

In order to run the test flow you need [Xilinx Vivado installed on your machine](../labs/lab0/README.md#install-xilinx-vivado).

A GNU `Makefile` is also used to **automate all flows** from the command line assuming a **Linux-like environment**.
If you work under Windows be sure that Linux basic commands and the `make` utility are available from the _Command Prompt_ as described
[here](../labs/lab0/README.md#add-linux-executables-to-search-path).


Open a terminal window and check if the `vivado` executable is properly found in the search path:

```
% which vivado
```

<br />

In case `vivado` in not found in the search path [invoke the proper setup script](../labs/lab0/README.md#add-xilinx-vivado-executables-to-search-path)
that comes with the Vivado installation.

On Linux:

```
% source /path/to/Vivado/<version>/settings64.(c)sh
```

<br />

On Windows:

```
% call \path\to\Vivado\<version>\settings64.bat
```


<br />
<!--------------------------------------------------------------------->


## Navigate to the test directory
[**[Contents]**](#contents)

To run the test flows, **open a terminal** window and change into the `fpga/test/` directory from the top of the Git repository:

```
% cd Desktop/lae/fpga/test
```

List content of the directory:

```
% ls -l
```

List all available `Makefile` targets with:

```
% make help
```

<br />

![](./doc/pictures/make_help.png)

<br />


<br />

>
> **IMPORTANT !**
>
> Each target in the `Makefile` is actually executed invoking a `bash` shell. Windows users might notice that
> a strange warning is generated when executing `make` targets:
>
> ```
> bash.exe: warning: could not find /tmp, please create
> ```
>
> This is a known problem and can be easily fixed by opening a `bash` session and creating the missing `/tmp` directory
> as expected by `bash`. To to this, launch `bash` in the _Command Prompt_ and create the missing directory:
>
> ```
> % bash
>
> Loading C:\Users\username\.bashrc
>
> bash$ mkdir /tmp
> bash$ exit
> %
> ```
>
> See also [this note](../lab0/KPAS.md) or _<https://stackoverflow.com/questions/22492715/bash-exe-warning-could-not-find-tmp-please-create>_.
>

<br />
<!--------------------------------------------------------------------->


## Setup the working area
[**[Contents]**](#contents)


Create a new fresh working area with:

```
% make area
```

Once done, explore the new content of the test directory:

```
% ls -l
```


<br />
<!--------------------------------------------------------------------->


## Compile IP cores
[**[Contents]**](#contents)

A Phase-Locked Loop (PLL) clock-management IP core is used to divide by a factor 10 the frequency of the input clock.
The IP is provided by Xilinx and has been customized using the _Clocking Wizard_ part of the **Vivado IP Catalog**.

Compile the IP to generate all related simulation and implementation sources as follows:

```
% make ip mode=batch xci=cores/PLL/PLL.xci
```

<br />

List new design data created by the flow:

```
% ls -l cores/PLL
```

<br />
<!--------------------------------------------------------------------->


## Run a behavioral simulation using XSim
[**[Contents]**](#contents)

Compile and elaborate the example HDL design and run the resulting simulation executable with:

```
% make compile
% make elaborate
% make simulate
```

<br />

For less typing, this is equivalent to run:

```
% make sim   (by default same as make sim mode=gui)
```

<br />

![](./doc/pictures/make_sim.png)

<br />

Display the full simulation time scale with **View > Zoom Fit**. Explore simulation results in the XSim graphical
interface. Once happy, close the window.

<br />

List the content of the directory that has been used to run the simulation:

```
% ls -l work/sim
```

<br />

You can also try to re-run the simulation in pure **batch mode** by specifying the `mode`
variable when invoking `make`:

```
% make sim mode=batch
```

<br />

Explore the content of provided simulation files using basic Linux commands, e.g. `cat`, `less` or `more`:

```
% cat  Makefile
% cat  rtl/Counter.v
% more rtl/ClockBuffer.vhd
% less scripts/sim/compile.tcl
```

<br />
<!--------------------------------------------------------------------->



## Implement the design on a target FPGA
[**[Contents]**](#contents)

Synthesize and map the example RTL code targeting a
[**Digilent Arty A7 development board**](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists/) with:

```
% make build   (by default same as make build mode=gui)
```

<br />

![](./doc/pictures/make_build.png)

<br />

Explore implementation results in the Vivado graphical interface. Once happy, close the window.

<br />

As for simulations, by default also the implementation flow runs in **graphic mode**.
You can try to re-run the flow in **interactive (Tcl)** or **batch modes** by specifying the
`mode` variable when invoking `make`:

```
% make build [mode=gui|tcl|batch]
```

<br />

List the contents of the directory that has been used to run the implementation flow:

```
% ls -l work/build
% ls -l work/build/reports
% ls -l work/build/outputs
```

<br />

Explore the content of the main **Xilinx Design Constraint (XDC)** file used to map the code to real FPGA hardware:

```
% cat xdc/Counter.xdc
```

<br />

Have also a first look to some **text reports** generated by the flow:

```
% ls -l work/builds/reports
% cat work/builds/reports/post_syn_utilization.rpt
```

<br />

Finally, try lo individuate **firmware configuration files** (_"bitstream"_ according to FPGA jargon) used to
program the FPGA or to write the firmware into the external 128-MB Quad SPI Flash memory:

```
% ls -l work/build/outputs
```

<br />
<!--------------------------------------------------------------------->


## <a name="install-and-debug-the-firmware"></a> Install and debug the firmware (optional)
[**[Contents]**](#contents)

<br />

>
> **IMPORTANT !**
>
> The following instructions are provided **only for reference**, you can test firmware installation flows
> only if you have a Digilent Arty A7 board attached to your personal computer!
>

<br />

At the end of the physical implementation flow you can test the design on real FPGA hardware.
Assuming that a board is connected to the host computer, upload the firmware from the command line using:

```
% make install [mode=batch]
```

<br />

The firmware loaded into the FPGA is stored into a volatile RAM inside the chip. By default the FPGA configuration is therefore **non-persistent**
across power cycles and you have to **re-program the FPGA** whenever you **disconnect the power** from the board.

In order to get the FPGA automatically programmed at power up you have to write the FPGA configuration into a dedicated
**external flash memory** as follows:

```
% make install_flash [mode=batch]
```

<br />

Please note that the firmware installation is a typical example of a very **automated and repetitive flow**, thus
working in **batch mode** with a **command-line approach** becomes more efficient than opening a graphical interface.

